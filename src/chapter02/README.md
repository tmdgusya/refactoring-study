# 2.1 리펙터링 정의
소프트웨어의 겉보기 동작은 그대로 유지한채 `코드를 이해하고 수정하기 쉽도록` 내부 구조를 변경하는 기법

리팩토링하는 동안에는 코드가 항상 정상 작도하기 때문에 `전체 작업이 끝나지 않았어도 언제든 멈출수있다`

리팩토링과 성능최적화는 비슷하지만 목적이 다르다 리팩터링의 목적은 코드를 이해하고 수정하기 쉽게 만드는 것이다. 프로그램의 성능은 좋아질수도 나빠질수도 있다.

반면 성능 최적화는 오로지 속도 개선에만 신경을 쓴다. 목표 성능에 다다르기 위해서는 코드가 어렵게 바뀔수도 있음을 각오해야한다.

# 2.2 두개의 모자

기능 추가와 리팩토링을 잘 구분해야함.

기능 추가할때는 기존 코드를 건들이지 말고 새 기능을 추가하기만 한다.
진척도는 테스트를 추가해가면서 측정ㅎ나다.

반면 리팩토링은 기능추가를 절대안하고 테스트도 새로 만들지 않는다. 

내가 하고있는 것이 기능 추가인지 리팩토링인지 잘 인지해야한다.

# 2.3 리팩터링 하는이유

1. 리팩터링을 하면 소프트웨어 설계가 좋아진다.

아키텍처를 충분히 이해하지 못한채 단기 목표만을 위해 코드를 수정하다보면 기반 구조가 무너지기 쉽다.
코드만 봐서 설계를 파악하기 어려워진다. -> 설계가 나빠진다. 
설계가 나쁘면 코드가 길어진다.

중복코드의 제거는 프로그래머의 숙원.

2. 소프트웨어를 이해하기 쉬워진다.
컴퓨터에게 시키려는 일과 이를 표현한 코드의 차이를 최대한 줄여야한다. 
협업하는 다른 사람을 위해 혹은 나를 위해.
읽기 쉬운 코드를 만들자.

3. 리팩터링하면 버그를 쉽게 찾을 수있다. 
코드를 이해하기 쉽다? -> 버그를 찾기 쉽다.

4. 프로그래밍 속도를 높일수있다.

# 2.4 언제 리팩터링해야할까

1. 처음에는 그냥한다. 
2. 비슷한 일을 두번째로 하게되면 계속 진행한다.
3. 세번째 하게되면 리팩터링한다.

기능을 쉽게 추가하게 만들기 위한 리팩터링
코드를 이해하기 쉽게 만들기 위한 리팩터링
쓰레기 줍기 리팩터링

개발에 들어가기 앞서 리팩터링 일정을 따로 잡아두지 않고 틈틈히 하는 것이다.

오래걸리는 리팩토링을 진행할때..
라이브러리 교체할때는 기존것과 새것을 모두 포용하는 추상 인터페이스 부터 마련한다. - 추상화로 갈아타기

리팩터링 하지 말아야할때
굳이 수정할 필요가 없다면, 내부동작을 이해할 필요가 없다면 
새로 작성하는게 더 빠르다면 

# 2.5 리팩터링 시 고려할 문제

새 기능 새발 속도 저하 
코드 소유권 - 함수 이름 바꾸기
브랜치
프로덕션 버젼으로 릴리스할때가 되서야 마스터에 통합하는 경우
마스터를 개인 브랜치로 수시로 리베이스나 머지한다. 


머지와 통합을 명확히 구분한다. 
마스터를 브랜치로 머지하는 작업은 단방향
반면에 통합은 개인브랜치로 마스터를 풀해서 작업한 결과를 다시 마스터에 올리는 양방향 처리르 뜻한다. (둘다 변경)

통합주기가 짧아야한다. 

# 2.8 리펙터링과 성능

최적화에 돌입되기 전까지는 성능에 신경쓰지 않고 코드를 다루기 쉽게 만드는데 집중한다. 
그러다 최적화를 하게되면 프로그램을 분석하여 시간과 공간을 많이 잡아먹는 지점을 알아낸다.



